//! Extension lock file for reproducible installs.
//!
//! The lock file at `.repository/extensions.lock` records the exact resolved
//! state of each installed extension so that subsequent installs on other
//! machines produce identical environments.
//!
//! # Format
//!
//! ```toml
//! # Auto-generated by repository-manager. Do not edit.
//!
//! [[extension]]
//! name = "vaultspec"
//! version = "0.1.0"
//! source = "https://github.com/vaultspec/vaultspec.git"
//! resolved_ref = "abc1234"
//! runtime_type = "python"
//! python_version = "3.13.1"
//! ```

use std::path::Path;

use serde::{Deserialize, Serialize};

use crate::error::{Error, Result};

/// The canonical filename for the extension lock file.
pub const LOCK_FILENAME: &str = "extensions.lock";

/// A lock file recording resolved extension state.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct LockFile {
    /// Locked extension entries.
    #[serde(default, rename = "extension")]
    pub extensions: Vec<LockedExtension>,
}

/// A single locked extension entry.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct LockedExtension {
    /// Extension name.
    pub name: String,
    /// Resolved semver version.
    pub version: String,
    /// Source URL or path.
    pub source: String,
    /// Resolved git ref (commit hash) if applicable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resolved_ref: Option<String>,
    /// Runtime type (e.g., "python", "rust", "node").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub runtime_type: Option<String>,
    /// Resolved Python version if runtime_type is "python".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub python_version: Option<String>,
}

impl LockFile {
    /// Create an empty lock file.
    pub fn new() -> Self {
        Self::default()
    }

    /// Parse a lock file from TOML content.
    pub fn from_toml(content: &str) -> Result<Self> {
        toml::from_str(content).map_err(|e| Error::LockFileParse(e.to_string()))
    }

    /// Read a lock file from disk.
    pub fn load(path: &Path) -> Result<Self> {
        if !path.exists() {
            return Ok(Self::new());
        }
        let content = std::fs::read_to_string(path)?;
        Self::from_toml(&content)
    }

    /// Serialize the lock file to TOML.
    pub fn to_toml(&self) -> Result<String> {
        let header = "# Auto-generated by repository-manager. Do not edit.\n\n";
        let body =
            toml::to_string_pretty(self).map_err(|e| Error::LockFileParse(e.to_string()))?;
        Ok(format!("{header}{body}"))
    }

    /// Write the lock file to disk.
    pub fn save(&self, path: &Path) -> Result<()> {
        let content = self.to_toml()?;
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        std::fs::write(path, content)?;
        Ok(())
    }

    /// Look up a locked extension by name.
    pub fn get(&self, name: &str) -> Option<&LockedExtension> {
        self.extensions.iter().find(|e| e.name == name)
    }

    /// Insert or update a locked extension entry.
    pub fn upsert(&mut self, entry: LockedExtension) {
        if let Some(existing) = self.extensions.iter_mut().find(|e| e.name == entry.name) {
            *existing = entry;
        } else {
            self.extensions.push(entry);
        }
        // Keep sorted for deterministic output
        self.extensions.sort_by(|a, b| a.name.cmp(&b.name));
    }

    /// Remove a locked extension by name. Returns true if it was found.
    pub fn remove(&mut self, name: &str) -> bool {
        let before = self.extensions.len();
        self.extensions.retain(|e| e.name != name);
        self.extensions.len() < before
    }

    /// Number of locked extensions.
    pub fn len(&self) -> usize {
        self.extensions.len()
    }

    /// Whether the lock file is empty.
    pub fn is_empty(&self) -> bool {
        self.extensions.is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_empty_lockfile() {
        let lock = LockFile::new();
        assert!(lock.is_empty());
        assert_eq!(lock.len(), 0);
    }

    #[test]
    fn test_upsert_and_get() {
        let mut lock = LockFile::new();
        lock.upsert(LockedExtension {
            name: "vaultspec".to_string(),
            version: "0.1.0".to_string(),
            source: "https://github.com/vaultspec/vaultspec.git".to_string(),
            resolved_ref: Some("abc1234".to_string()),
            runtime_type: Some("python".to_string()),
            python_version: Some("3.13.1".to_string()),
        });

        assert_eq!(lock.len(), 1);
        let entry = lock.get("vaultspec").unwrap();
        assert_eq!(entry.version, "0.1.0");
        assert_eq!(entry.resolved_ref.as_deref(), Some("abc1234"));
    }

    #[test]
    fn test_upsert_replaces() {
        let mut lock = LockFile::new();
        lock.upsert(LockedExtension {
            name: "ext".to_string(),
            version: "1.0.0".to_string(),
            source: "https://example.com".to_string(),
            resolved_ref: None,
            runtime_type: None,
            python_version: None,
        });
        lock.upsert(LockedExtension {
            name: "ext".to_string(),
            version: "2.0.0".to_string(),
            source: "https://example.com".to_string(),
            resolved_ref: None,
            runtime_type: None,
            python_version: None,
        });

        assert_eq!(lock.len(), 1);
        assert_eq!(lock.get("ext").unwrap().version, "2.0.0");
    }

    #[test]
    fn test_remove() {
        let mut lock = LockFile::new();
        lock.upsert(LockedExtension {
            name: "ext".to_string(),
            version: "1.0.0".to_string(),
            source: "src".to_string(),
            resolved_ref: None,
            runtime_type: None,
            python_version: None,
        });

        assert!(lock.remove("ext"));
        assert!(lock.is_empty());
        assert!(!lock.remove("ext")); // Already gone
    }

    #[test]
    fn test_sorted_output() {
        let mut lock = LockFile::new();
        lock.upsert(LockedExtension {
            name: "zebra".to_string(),
            version: "1.0.0".to_string(),
            source: "z".to_string(),
            resolved_ref: None,
            runtime_type: None,
            python_version: None,
        });
        lock.upsert(LockedExtension {
            name: "alpha".to_string(),
            version: "1.0.0".to_string(),
            source: "a".to_string(),
            resolved_ref: None,
            runtime_type: None,
            python_version: None,
        });

        assert_eq!(lock.extensions[0].name, "alpha");
        assert_eq!(lock.extensions[1].name, "zebra");
    }

    #[test]
    fn test_toml_round_trip() {
        let mut lock = LockFile::new();
        lock.upsert(LockedExtension {
            name: "vaultspec".to_string(),
            version: "0.1.0".to_string(),
            source: "https://github.com/vaultspec/vaultspec.git".to_string(),
            resolved_ref: Some("abc1234".to_string()),
            runtime_type: Some("python".to_string()),
            python_version: Some("3.13.1".to_string()),
        });

        let toml_str = lock.to_toml().unwrap();
        assert!(toml_str.contains("Auto-generated"));

        let reparsed = LockFile::from_toml(&toml_str).unwrap();
        assert_eq!(reparsed.len(), 1);
        assert_eq!(reparsed.get("vaultspec").unwrap().version, "0.1.0");
    }

    #[test]
    fn test_save_and_load() {
        let tmp = TempDir::new().unwrap();
        let path = tmp.path().join(LOCK_FILENAME);

        let mut lock = LockFile::new();
        lock.upsert(LockedExtension {
            name: "test".to_string(),
            version: "1.0.0".to_string(),
            source: "local".to_string(),
            resolved_ref: None,
            runtime_type: None,
            python_version: None,
        });

        lock.save(&path).unwrap();
        assert!(path.exists());

        let loaded = LockFile::load(&path).unwrap();
        assert_eq!(loaded.len(), 1);
        assert_eq!(loaded.get("test").unwrap().version, "1.0.0");
    }

    #[test]
    fn test_load_missing_returns_empty() {
        let tmp = TempDir::new().unwrap();
        let path = tmp.path().join("nonexistent.lock");
        let loaded = LockFile::load(&path).unwrap();
        assert!(loaded.is_empty());
    }

    #[test]
    fn test_optional_fields_omitted_in_toml() {
        let mut lock = LockFile::new();
        lock.upsert(LockedExtension {
            name: "minimal".to_string(),
            version: "1.0.0".to_string(),
            source: "src".to_string(),
            resolved_ref: None,
            runtime_type: None,
            python_version: None,
        });

        let toml_str = lock.to_toml().unwrap();
        assert!(!toml_str.contains("resolved_ref"));
        assert!(!toml_str.contains("runtime_type"));
        assert!(!toml_str.contains("python_version"));
    }
}
