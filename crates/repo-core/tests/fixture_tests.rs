//! Golden-file tests using test-fixtures/
//!
//! These tests wire the test-fixtures directory into actual integration tests,
//! verifying that syncing rules to tools produces the expected output files.
//!
//! Golden files are authored from tool documentation, NOT generated by
//! the code under test. See test-fixtures/expected/README.md for rules.

use pretty_assertions::assert_eq;
use repo_core::ledger::Ledger;
use repo_core::sync::ToolSyncer;
use repo_fs::NormalizedPath;
use repo_tools::Rule;
use std::fs;
use std::path::PathBuf;
use tempfile::tempdir;

/// Normalize line endings to LF and trim trailing whitespace per line.
///
/// Handles cross-platform line ending differences and trailing spaces
/// that may be stripped by editors or the filesystem layer.
fn normalize(s: &str) -> String {
    s.replace("\r\n", "\n")
        .lines()
        .map(|line| line.trim_end())
        .collect::<Vec<_>>()
        .join("\n")
}

/// Strip provenance header lines from golden file content.
///
/// Provenance lines are metadata comments at the top of each golden file
/// (format source, last-validated date, etc). They are not part of the
/// expected output. This function removes them so the golden file content
/// can be compared against generated output.
fn strip_provenance_header(content: &str) -> String {
    const PROVENANCE_MARKERS: &[&str] = &[
        "Golden file:",
        "Format source:",
        "Last validated:",
        "WARNING: Do not regenerate",
    ];

    let mut lines = content.lines().peekable();
    let mut skipped = false;

    // Skip leading lines that contain any provenance marker
    while let Some(&line) = lines.peek() {
        let trimmed = line.trim();
        let is_provenance = PROVENANCE_MARKERS
            .iter()
            .any(|marker| trimmed.contains(marker));

        if is_provenance {
            lines.next();
            skipped = true;
        } else if skipped && trimmed.is_empty() {
            // Skip a blank line immediately after provenance block
            lines.next();
            break;
        } else {
            break;
        }
    }

    let remaining: Vec<&str> = lines.collect();
    remaining.join("\n") + if content.ends_with('\n') { "\n" } else { "" }
}

/// Path to the test-fixtures directory (relative to the workspace root).
fn fixtures_dir() -> PathBuf {
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    // crates/repo-core -> ../../test-fixtures
    manifest_dir.join("../../test-fixtures")
}

/// Read the coding-standards rule from the config-test fixture.
fn load_coding_standards_rule() -> Rule {
    let rule_path = fixtures_dir().join("repos/config-test/.repository/rules/coding-standards.md");
    let content = fs::read_to_string(&rule_path).unwrap_or_else(|e| {
        panic!(
            "Failed to read fixture rule at {}: {}",
            rule_path.display(),
            e
        )
    });
    Rule {
        id: "coding-standards".to_string(),
        content,
    }
}

/// Read the expected output for a tool from test-fixtures/expected/.
fn load_expected_output(tool_dir: &str, filename: &str) -> String {
    let path = fixtures_dir()
        .join("expected")
        .join(tool_dir)
        .join(filename);
    fs::read_to_string(&path).unwrap_or_else(|e| {
        panic!(
            "Failed to read expected output at {}: {}",
            path.display(),
            e
        )
    })
}

// ==========================================================================
// Fixture Validity Tests
// ==========================================================================

#[test]
fn test_config_test_fixture_has_valid_manifest() {
    let config_path = fixtures_dir().join("repos/config-test/.repository/config.toml");
    let content = fs::read_to_string(&config_path).unwrap();

    // Should parse as a valid Manifest
    let manifest = repo_core::Manifest::parse(&content).unwrap();
    assert_eq!(manifest.core.mode, "standard");
    assert!(
        !manifest.tools.is_empty(),
        "config-test fixture should declare at least one tool"
    );
    assert!(
        manifest.tools.contains(&"cursor".to_string()),
        "config-test fixture should include cursor tool, got: {:?}",
        manifest.tools
    );
    assert!(
        manifest.tools.contains(&"claude".to_string()),
        "config-test fixture should include claude tool, got: {:?}",
        manifest.tools
    );
}

#[test]
fn test_coding_standards_rule_is_non_empty() {
    let rule = load_coding_standards_rule();
    assert!(
        !rule.content.is_empty(),
        "Coding standards rule should have content"
    );
    assert!(
        rule.content.contains("rustfmt"),
        "Coding standards should mention rustfmt"
    );
    assert!(
        rule.content.contains("clippy"),
        "Coding standards should mention clippy"
    );
}

// ==========================================================================
// Golden-File Tests: Sync Rule to Tools and Compare Output
// ==========================================================================

#[test]
fn test_golden_file_cursor_output_matches_expected() {
    let temp = tempdir().unwrap();
    let root = NormalizedPath::new(temp.path());

    let syncer = ToolSyncer::new(root.clone(), false);
    let mut ledger = Ledger::new();
    let rule = load_coding_standards_rule();

    syncer
        .sync_tool_with_rules("cursor", &[rule], &mut ledger)
        .unwrap();

    // Read the generated .cursorrules file
    let generated_path = temp.path().join(".cursorrules");
    assert!(
        generated_path.exists(),
        ".cursorrules should be created after sync"
    );
    let generated = fs::read_to_string(&generated_path).unwrap();

    // Structural checks (survive formatting changes)
    assert!(generated.contains("<!-- repo:block:coding-standards -->"));
    assert!(generated.contains("<!-- /repo:block:coding-standards -->"));
    assert!(generated.contains("rustfmt"));
    assert!(generated.contains("clippy"));

    // Block marker count: every open must have a matching close
    let open = generated.matches("<!-- repo:block:").count();
    let close = generated.matches("<!-- /repo:block:").count();
    assert_eq!(open, close, "Open and close marker counts must match");

    // Full comparison against golden file (provenance headers stripped)
    let expected = load_expected_output("cursor", ".cursorrules");
    let expected_content = strip_provenance_header(&expected);
    assert_eq!(
        normalize(&generated).trim(),
        normalize(&expected_content).trim(),
        "Generated .cursorrules should match the expected golden file"
    );
}

#[test]
fn test_golden_file_claude_output_matches_expected() {
    let temp = tempdir().unwrap();
    let root = NormalizedPath::new(temp.path());

    let syncer = ToolSyncer::new(root.clone(), false);
    let mut ledger = Ledger::new();
    let rule = load_coding_standards_rule();

    syncer
        .sync_tool_with_rules("claude", &[rule], &mut ledger)
        .unwrap();

    // Read the generated CLAUDE.md file
    let generated_path = temp.path().join("CLAUDE.md");
    assert!(
        generated_path.exists(),
        "CLAUDE.md should be created after sync"
    );
    let generated = fs::read_to_string(&generated_path).unwrap();

    // Structural checks (survive formatting changes)
    assert!(generated.contains("<!-- repo:block:coding-standards -->"));
    assert!(generated.contains("<!-- /repo:block:coding-standards -->"));
    assert!(generated.contains("rustfmt"));
    assert!(generated.contains("clippy"));

    // Block marker count
    let open = generated.matches("<!-- repo:block:").count();
    let close = generated.matches("<!-- /repo:block:").count();
    assert_eq!(open, close, "Open and close marker counts must match");

    // Full comparison against golden file (provenance headers stripped)
    let expected = load_expected_output("claude", "CLAUDE.md");
    let expected_content = strip_provenance_header(&expected);
    assert_eq!(
        normalize(&generated).trim(),
        normalize(&expected_content).trim(),
        "Generated CLAUDE.md should match the expected golden file"
    );
}

#[test]
fn test_golden_file_aider_output_matches_expected() {
    let temp = tempdir().unwrap();
    let root = NormalizedPath::new(temp.path());

    let syncer = ToolSyncer::new(root.clone(), false);
    let mut ledger = Ledger::new();
    let rule = load_coding_standards_rule();

    syncer
        .sync_tool_with_rules("aider", &[rule], &mut ledger)
        .unwrap();

    // Read the generated .aider.conf.yml file
    let generated_path = temp.path().join(".aider.conf.yml");
    assert!(
        generated_path.exists(),
        ".aider.conf.yml should be created after sync"
    );
    let generated = fs::read_to_string(&generated_path).unwrap();

    // Structural checks: YAML comment block markers
    assert!(
        generated.contains("# repo:block:coding-standards"),
        "Aider output must contain YAML comment open marker"
    );
    assert!(
        generated.contains("# /repo:block:coding-standards"),
        "Aider output must contain YAML comment close marker"
    );
    assert!(
        !generated.contains("<!-- repo:block:"),
        "Aider YAML must NOT contain HTML comment markers"
    );
    assert!(
        generated.contains("rustfmt"),
        "Rule content must be present"
    );
    assert!(generated.contains("clippy"), "Rule content must be present");

    // YAML validity: the file should parse as valid YAML
    let yaml_result: Result<serde_yaml::Value, _> = serde_yaml::from_str(&generated);
    assert!(
        yaml_result.is_ok(),
        "Generated .aider.conf.yml must be valid YAML: {:?}",
        yaml_result.err()
    );

    // Full comparison against golden file (provenance headers stripped)
    let expected = load_expected_output("aider", ".aider.conf.yml");
    let expected_content = strip_provenance_header(&expected);
    assert_eq!(
        normalize(&generated).trim(),
        normalize(&expected_content).trim(),
        "Generated .aider.conf.yml should match the expected golden file"
    );
}

// ==========================================================================
// Fixture-Based Multi-Tool Sync Test
// ==========================================================================

#[test]
fn test_config_test_fixture_syncs_all_declared_tools() {
    let config_path = fixtures_dir().join("repos/config-test/.repository/config.toml");
    let content = fs::read_to_string(&config_path).unwrap();
    let manifest = repo_core::Manifest::parse(&content).unwrap();

    let temp = tempdir().unwrap();
    let root = NormalizedPath::new(temp.path());
    let syncer = ToolSyncer::new(root.clone(), false);
    let mut ledger = Ledger::new();

    let rule = load_coding_standards_rule();

    // Sync each tool declared in the fixture config
    for tool_name in &manifest.tools {
        if syncer.has_tool(tool_name) {
            let actions = syncer
                .sync_tool_with_rules(tool_name, std::slice::from_ref(&rule), &mut ledger)
                .unwrap();
            assert!(
                !actions.is_empty(),
                "Syncing tool '{}' should produce at least one action",
                tool_name
            );
        }
    }

    // Verify that synced tools created files
    // cursor -> .cursorrules
    let cursorrules = temp.path().join(".cursorrules");
    assert!(
        cursorrules.exists(),
        ".cursorrules should exist after cursor sync"
    );
    let cursor_content = fs::read_to_string(&cursorrules).unwrap();
    assert!(
        cursor_content.contains("coding-standards"),
        ".cursorrules should contain coding-standards block marker"
    );

    // claude -> CLAUDE.md
    let claude_md = temp.path().join("CLAUDE.md");
    assert!(
        claude_md.exists(),
        "CLAUDE.md should exist after claude sync"
    );
    let claude_content = fs::read_to_string(&claude_md).unwrap();
    assert!(
        claude_content.contains("coding-standards"),
        "CLAUDE.md should contain coding-standards block marker"
    );
}

// ==========================================================================
// Simple-Project Fixture Tests
// ==========================================================================

#[test]
fn test_simple_project_fixture_files_exist() {
    // Verify the simple-project fixture has the expected structure
    let base = fixtures_dir().join("repos/simple-project");

    let expected_files = [
        "Cargo.toml",
        "CLAUDE.md",
        "GEMINI.md",
        ".aider.conf.yml",
        "src/main.rs",
    ];

    for file in &expected_files {
        let path = base.join(file);
        assert!(
            path.exists(),
            "Simple-project fixture should contain {}, but it's missing at {}",
            file,
            path.display()
        );
    }
}

#[test]
fn test_simple_project_claude_md_has_expected_structure() {
    let path = fixtures_dir().join("repos/simple-project/CLAUDE.md");
    let content = fs::read_to_string(&path).unwrap();

    // The simple-project CLAUDE.md is a manually written file (not managed blocks)
    // It should be a markdown document with a heading
    assert!(
        content.starts_with("# "),
        "CLAUDE.md should start with a heading, got: {}",
        content.chars().take(20).collect::<String>()
    );
    assert!(
        content.contains("Rules") || content.contains("rules"),
        "CLAUDE.md should mention rules"
    );
}

#[test]
fn test_simple_project_aider_config_is_valid_yaml() {
    let path = fixtures_dir().join("repos/simple-project/.aider.conf.yml");
    let content = fs::read_to_string(&path).unwrap();

    // Basic YAML validity checks (not a full parser, but structural checks)
    assert!(
        content.contains("model:"),
        "Aider config should contain a model key"
    );
    assert!(
        content.contains("auto-commits:"),
        "Aider config should contain auto-commits key"
    );
}

// ==========================================================================
// Expected Output Structure Tests
// ==========================================================================

#[test]
fn test_expected_outputs_contain_managed_block_markers() {
    // The expected/ directory files should all contain repo:block markers
    let expected_dir = fixtures_dir().join("expected");

    let checks = vec![
        ("claude/CLAUDE.md", "repo:block:coding-standards"),
        ("cursor/.cursorrules", "repo:block:coding-standards"),
        ("aider/.aider.conf.yml", "repo:block:coding-standards"),
    ];

    for (rel_path, marker) in checks {
        let path = expected_dir.join(rel_path);
        let content = fs::read_to_string(&path)
            .unwrap_or_else(|e| panic!("Failed to read {}: {}", path.display(), e));
        assert!(
            content.contains(marker),
            "Expected output {} should contain marker '{}', got:\n{}",
            rel_path,
            marker,
            content
        );
    }
}

#[test]
fn test_expected_outputs_have_matching_open_close_markers() {
    let expected_dir = fixtures_dir().join("expected");

    let files = vec!["claude/CLAUDE.md", "cursor/.cursorrules"];

    for rel_path in files {
        let path = expected_dir.join(rel_path);
        let content = fs::read_to_string(&path).unwrap();

        let open_count = content.matches("<!-- repo:block:").count();
        let close_count = content.matches("<!-- /repo:block:").count();

        assert_eq!(
            open_count, close_count,
            "{}: open markers ({}) should equal close markers ({})",
            rel_path, open_count, close_count
        );
        assert!(
            open_count > 0,
            "{}: should have at least one block marker pair",
            rel_path
        );
    }
}

#[test]
fn test_expected_outputs_have_provenance_headers() {
    let expected_dir = fixtures_dir().join("expected");

    let files = vec![
        "cursor/.cursorrules",
        "claude/CLAUDE.md",
        "aider/.aider.conf.yml",
    ];

    for rel_path in files {
        let path = expected_dir.join(rel_path);
        let content = fs::read_to_string(&path).unwrap();

        assert!(
            content.contains("Golden file:"),
            "{}: must have 'Golden file:' provenance line",
            rel_path
        );
        assert!(
            content.contains("Format source:"),
            "{}: must have 'Format source:' provenance line",
            rel_path
        );
        assert!(
            content.contains("Last validated:"),
            "{}: must have 'Last validated:' provenance line",
            rel_path
        );
        assert!(
            content.contains("WARNING: Do not regenerate"),
            "{}: must have regeneration warning",
            rel_path
        );
    }
}

// ==========================================================================
// Provenance Stripping Helper Test
// ==========================================================================

#[test]
fn test_strip_provenance_header_removes_metadata() {
    let input = r#"<!-- Golden file: test -->
<!-- Format source: test docs -->
<!-- Last validated: 2026-01-01 -->
<!-- WARNING: Do not regenerate from code. Edit manually from spec. -->
actual content here
"#;
    let stripped = strip_provenance_header(input);
    assert!(
        !stripped.contains("Golden file:"),
        "Provenance should be stripped"
    );
    assert!(
        stripped.contains("actual content here"),
        "Content should remain"
    );
}

#[test]
fn test_strip_provenance_header_passes_through_no_provenance() {
    let input = "no provenance here\njust content\n";
    let stripped = strip_provenance_header(input);
    assert_eq!(
        stripped, input,
        "Content without provenance should be unchanged"
    );
}
